from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
import json
from datetime import datetime, timedelta
from typing import Optional
import pandas as pd

from utils.loader import load_data
from services.cbf_service import CBFSystemNormalizedProximity
from services.cbr_service import get_cbr_recommendation
from services.hybrid_service import get_hybrid_recommendation
from services.save_service import save_recommendations_to_db
from services.save_temp_service import save_temp_recommendations_to_db

app = FastAPI(title="Rekomendasi Perkuliahan API")

# ================= ENABLE CORS =================
origins = [
    "http://localhost:3000",
    "http://127.0.0.1:3000",
    "*"
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ================= Helper =================
def safe_to_list_of_dict(df_or_list):
    if hasattr(df_or_list, "to_dict"):
        return df_or_list.to_dict(orient="records")
    elif isinstance(df_or_list, list):
        result = []
        for row in df_or_list:
            if isinstance(row, dict):
                result.append(row)
            elif isinstance(row, str):
                try:
                    result.append(json.loads(row))
                except:
                    continue
        return result
    return []

# ================= CBF ALL =================
@app.get("/recommend/cbf/all")
def recommend_cbf_all(
    track: str = "science",
    top_n: int = 20,
    page: int = 1,
    size: int = 20,
    save: bool = True,
    permanent: bool = False,
):
    try:
        science_data, humanities_data, passing_data = load_data()

        if track == "science":
            df_scores = science_data
            df_pg = [row for row in safe_to_list_of_dict(passing_data) if row.get("type") == "science"]
        elif track == "humanities":
            df_scores = humanities_data
            df_pg = [row for row in safe_to_list_of_dict(passing_data) if row.get("type") == "humanities"]
        else:
            raise HTTPException(status_code=400, detail="Track harus 'science' atau 'humanities'")

        df_scores_list = safe_to_list_of_dict(df_scores)
        if not df_scores_list:
            raise HTTPException(status_code=404, detail=f"Tidak ada data untuk track {track}")

        cbf = CBFSystemNormalizedProximity(df_scores_list, df_pg)

        all_recommendations = []

        # Generate semua user (mirip cache)
        sim_data_all = cbf.retrieve(user_id=None, top_n=top_n)
        recs_all = cbf.recommend_prodi(sim_data_all)
        if recs_all.empty:
            raise HTTPException(status_code=404, detail="Tidak ditemukan rekomendasi")

        # Tambahkan query_user_id
        recs_all["query_user_id"] = recs_all["id_user"]

        # Save to temp_recommendations
        if save:
            expired_at = datetime.now() + timedelta(hours=1)
            for user_id, group in recs_all.groupby("query_user_id"):
                save_temp_recommendations_to_db(user_id, group.to_dict(orient="records"), "CBF", track, expired_at)

        all_recommendations = recs_all

        # Pagination
        total = len(all_recommendations)
        start = (page - 1) * size
        end = start + size
        paginated = all_recommendations[start:end].to_dict(orient="records")

        return {
            "page": page,
            "size": size,
            "total": total,
            "total_pages": (total + size - 1) // size,
            "data": paginated
        }

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"CBF Error: {str(e)}")


# ================= CBR ALL =================
@app.get("/recommend/cbr/all")
def recommend_cbr_all(
    track: str = "science",
    top_n: int = 20,
    page: int = 1,
    size: int = 20,
    save: bool = True,
    permanent: bool = False,
):
    try:
        science_data, humanities_data, _ = load_data()
        if track == "science":
            df_scores = science_data
        elif track == "humanities":
            df_scores = humanities_data
        else:
            raise HTTPException(status_code=400, detail="Track harus 'science' atau 'humanities'")

        df_scores_list = safe_to_list_of_dict(df_scores)
        if not df_scores_list:
            raise HTTPException(status_code=404, detail=f"Tidak ada data untuk track {track}")

        all_recommendations = []
        for row in df_scores_list:
            user_id = row.get("id_user")
            result = get_cbr_recommendation(user_id, track, top_n)
            if result:
                for r in result:
                    r["id_user"] = user_id
                all_recommendations.extend(result)

                # save to temp
                if save:
                    expired_at = datetime.now() + timedelta(hours=1)
                    save_temp_recommendations_to_db(user_id, result, "CBR", track, expired_at)

        # Pagination
        total = len(all_recommendations)
        start = (page - 1) * size
        end = start + size
        paginated = all_recommendations[start:end]

        return {
            "page": page,
            "size": size,
            "total": total,
            "total_pages": (total + size - 1) // size,
            "data": paginated
        }

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"CBR Error: {str(e)}")


# ================= HYBRID ALL =================
@app.get("/recommend/hybrid/all")
def recommend_hybrid_all(
    track: str = "science",
    top_n: int = 20,
    weight_cbf: float = 0.5,
    weight_cbr: float = 0.5,
    page: int = 1,
    size: int = 20,
    save: bool = True,
    permanent: bool = False,
):
    try:
        science_data, humanities_data, _ = load_data()
        if track == "science":
            df_scores = science_data
        elif track == "humanities":
            df_scores = humanities_data
        else:
            raise HTTPException(status_code=400, detail="Track harus 'science' atau 'humanities'")

        df_scores_list = safe_to_list_of_dict(df_scores)
        if not df_scores_list:
            raise HTTPException(status_code=404, detail=f"Tidak ada data untuk track {track}")

        all_recommendations = []
        for row in df_scores_list:
            user_id = row.get("id_user")
            result = get_hybrid_recommendation(user_id, track, top_n, weight_cbf, weight_cbr)
            if result:
                for r in result:
                    r["id_user"] = user_id
                all_recommendations.extend(result)

                # save to temp
                if save:
                    expired_at = datetime.now() + timedelta(hours=1)
                    save_temp_recommendations_to_db(user_id, result, "HYBRID", track, expired_at)

        # Pagination
        total = len(all_recommendations)
        start = (page - 1) * size
        end = start + size
        paginated = all_recommendations[start:end]

        return {
            "page": page,
            "size": size,
            "total": total,
            "total_pages": (total + size - 1) // size,
            "data": paginated
        }

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Hybrid Error: {str(e)}")



